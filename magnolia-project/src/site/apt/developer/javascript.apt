Javasript Conventions

  Javascript is a very often misunderstood programming language because it's different to Java! A lot of Java developers uses javascript the same way as Java and are frustrated after a while because nothing seams to work as it should.

* Javascript Concepts

  First some words about javascript. Its evident that you understand the following concepts.

** OOP
  JS uses inheritance by prototype and has not a concept of classes and objects like in JAVA. Said in short words: everything is an Object. A Function is an Object and each function can be called as a consrtuctor

  The following lines are showing the inheritance by prototype:

--------------------
<script>
function (o){
    document.write(o + "<br>");
}

function SuperClass(){
    this.a = "a";
    this.show = function(){
        print("show function of super class: " + this.a);
    }
}

SuperClass.prototype.b = "b";

function SubClass(){
    this.c = "c";
}

SubClass.prototype = new SuperClass();
SubClass.prototype.d = "d";

sub = new SubClass();
sup = new SuperClass();

print("inheritance by prototype");

print("a of subclass: " + sub.a);
print("b of subclass: " + sub.b);
print("c of subclass: " + sub.c);
print("d of subclass: " + sub.d);

print("a of subclass: " + sup.a);
print("b of subclass: " + sup.b);
print("c of superclass: " + sup.c);
print("d of superclass: " + sup.d);

--------------------

  The result of this code is as it should be:

--------------------
a of subclass: a
b of subclass: b
c of subclass: c
d of subclass: d
a of subclass: a
b of subclass: b
c of superclass: undefined
d of superclass: undefined
--------------------

  This shows clearly that a Constructor takes an Object as its prototype.

** Closures

 This is a concept not found in JAVA. A function has all the variables avaiable which were present during the creation of a function.

--------------------
function closureTest(){
    var msg = "the message";
    return function (){
        alert(msg);
    }
}

// would not work
// alert(msg);

// call the returned inner function
var functionWithClosure = closureTest();
functionWithClosure();
--------------------

 This will alert "the message". The same mechansim can be used to create private properties

--------------------
function MyClass(){
    var private = "you can't set me!";
    this.getPrivate(){
        return private;
    }
}
--------------------


** lambda calculus

  This brings JS a lot of flexibility. One can define anonnymoud functions for example.

-------------------
  text.onclick = function(e){alert this.value};
-------------------

  This shows the value of a text field after clicking

-------------------
alert((function(a,b){return a + b})(5,4));
-------------------

  This alerts 9

** this

  The variable this is sometimes confusing since it is working with closures too.

-------------------
var test = {
    this.value = "test";
    function show(){
        alert(this.value);
    }
}

button.onclick = test.show;
-------------------

  A JAVA developer will expect that the value "test" gets alerted but this not true. Instead the value of the button gets alerted.
  This means that this is always referencing the closest this to the method call. One could handle this as following.

-------------------
button.onclick = function(){test.show()};
-------------------

